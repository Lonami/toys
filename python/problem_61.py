def problem_definition():
    return '''Cyclical figurate numbers

    Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate
    (polygonal) numbers and are generated by the following formulae:

                Triangle 	  	P_3,n=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
                Square 	  	    P_4,n=n² 	  	    1, 4, 9, 16, 25, ...
                Pentagonal 	  	P_5,n=n(3n−1)/2 	1, 5, 12, 22, 35, ...
                Hexagonal 	  	P_6,n=n(2n−1) 	  	1, 6, 15, 28, 45, ...
                Heptagonal 	  	P_7,n=n(5n−3)/2 	1, 7, 18, 34, 55, ...
                Octagonal 	  	P_8,n=n(3n−2) 	  	1, 8, 21, 40, 65, ...

    The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

        - The set is cyclic, in that the last two digits of each number is the first two digits of the
          next number (including the last number with the first).
        - Each polygonal type: triangle (P_3,127=8128), square (P_4,91=8281), and pentagonal (P_5,44=2882),
          is represented by a different number in the set.
        - This is the only set of 4-digit numbers with this property.

    Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
    triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different
    number in the set.'''


# Step 1. Define all functions
def p3(n):
    return n * (n + 1) // 2


def p4(n):
    return n ** 2


def p5(n):
    return n * (3 * n - 1) // 2


def p6(n):
    return n * (2 * n - 1)


def p7(n):
    return n * (5 * n - 3) // 2


def p8(n):
    return n * (3 * n - 2)


# Step 2. Calculate all the 4-digit values for all the functions
p3s = tuple(str(p3(x)) for x in range(1, 10000) if 1000 <= p3(x) <= 9999)
p4s = tuple(str(p4(x)) for x in range(1, 10000) if 1000 <= p4(x) <= 9999)
p5s = tuple(str(p5(x)) for x in range(1, 10000) if 1000 <= p5(x) <= 9999)
p6s = tuple(str(p6(x)) for x in range(1, 10000) if 1000 <= p6(x) <= 9999)
p7s = tuple(str(p7(x)) for x in range(1, 10000) if 1000 <= p7(x) <= 9999)
p8s = tuple(str(p8(x)) for x in range(1, 10000) if 1000 <= p8(x) <= 9999)

# Step 3. Store the lists in another list, for iterating it after
pns = tuple([p3s, p4s, p5s, p6s, p7s, p8s])


# Step 4. Define a first check, which doesn't need to check if the last string "joins" with the new one
def check_first():
    for i in range(6):
        # Available checks, all j's but this i
        available_checks = [i != j for j in range(6)]

        # For every value in this pn (0: triangle, 1: square, ...), create a new string and check
        for pn in pns[i]:
            current_str = str(pn)
            check(current_str, available_checks)


# Step 5, 6, 7... . Check if it's cyclic, and, if no more checks available, print it
def check(current_str, available_checks):

    # If there's any check, go ahead
    if any(available_checks):
        for i in range(6):
            if available_checks[i]:
                # Update a cloned list to indicate we can't check this pn anymore
                new_checks = list(available_checks)
                new_checks[i] = False

                # For each pn in this pn iteration
                for pn in pns[i]:
                    spn = str(pn)
                    # If it doesn't start with the end of the other (not cyclic), forget it!
                    if current_str[-2:] != spn[:2]:
                        continue

                    # Otherwise, these were cyclic, append and go ahead
                    check(current_str + spn, new_checks)

    # Else if no more checks, ensure the last bit of the string equals the first
    elif current_str[:2] == current_str[-2:]:
        numbers = [int(current_str[i:i+4]) for i in range(0, len(current_str), 4)]
        print('Found unordered set: {}, which adds to {}'.format(numbers, sum(numbers)))


check_first()
